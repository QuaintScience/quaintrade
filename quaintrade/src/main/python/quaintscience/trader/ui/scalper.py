# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'scalper.ui'
#
# Created by: PyQt5 UI code generator 5.15.10
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import sys
import os
import datetime, time
import yaml
import logging
import copy
import traceback
import threading
from functools import partial
import pandas as pd
from PyQt5.QtWidgets import QApplication, QLabel, QWidget, QHBoxLayout, QVBoxLayout, QLineEdit, QPushButton, QComboBox, QTabWidget, QListWidget, QDialogButtonBox, QDialog, QCheckBox, QTextEdit, QTableView, QGridLayout, QRadioButton, QInputDialog, QShortcut, QListView, QSpacerItem, QSizePolicy
from PyQt5.QtCore import QUrl, QAbstractTableModel, Qt, QVariant
from PyQt5.QtGui import QDesktopServices
from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qtagg import NavigationToolbar2QT as NavigationToolbar
from matplotlib.figure import Figure
from lightweight_charts.widgets import QtChart

from jugaad_data.nse import NSELive

from typing import Optional
from quaintscience.trader.service.common import DataProviderService, BrokerService, Service
from quaintscience.trader.core.roles import Broker
from quaintscience.trader.core.bot import Bot
from quaintscience.trader.core.ds import TradeType, Order, TransactionType, TradingProduct, OrderType
from quaintscience.trader.core.graphing import live_ohlc_plot
from quaintscience.trader.core.strategy import Strategy
from quaintscience.trader.core.indicator import MAIndicator, IndicatorPipeline
from quaintscience.trader.integration.nselive import NSELiveHandler
from pyqttoast import Toast, ToastPreset

INTEGRATIONS = ["Fyers", "Neo"]


class EMAStrategy(Strategy):

    def __init__(self,
                 *args,
                 ema_period1: int = 9,
                 ema_period2: int = 22,
                 **kwargs):
        self.ema1 = MAIndicator(period=ema_period1, signal="close", ma_type="EMA")
        self.ema2 = MAIndicator(period=ema_period2, signal="close", ma_type="EMA")
        indicators =[
                    (self.ema1, None, None),
                    (self.ema2, None, None)
                    ]
        indicators = IndicatorPipeline(indicators)
        kwargs["indicator_pipeline"] = {"window": indicators,
                                        "context": {}}
        super().__init__(*args, **kwargs)

    def apply_impl(self,
                   broker: Broker,
                   scrip: str,
                   exchange: str,
                   window: pd.DataFrame,
                   context: dict[str, pd.DataFrame]) -> Optional[TradeType]:
        pass

class TableModel(QAbstractTableModel):

    def __init__(self, data: pd.DataFrame):
        super(TableModel, self).__init__()
        self._data = data

    def data(self, index, role=Qt.DisplayRole):
        if index.isValid():
            if role == Qt.DisplayRole:
                return QVariant(str(
                    self._data.iloc[index.row()][index.column()]))
        return QVariant()

    def rowCount(self, parent=None):
        return len(self._data.values)

    def columnCount(self, parent=None):
        return self._data.columns.size
    

    def headerData(self, col, orientation, role):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self._data.columns[col]
        return None

class ScalperApp():

    def __init__(self,
                 settings_file: str = ".auth.env"):
        self.logger = logging.getLogger()
        self.logger.setLevel(logging.DEBUG)
        self.logger.addHandler(logging.StreamHandler())
        self.settings_file = settings_file
        self.nse_live_handler = NSELiveHandler()
        self.config = {}
        self.provider_objs = {}
        self.bot = None
        self.ui_instruments = {"1l" : None, "2l": None, "1r": None, "2r": None}
        self.location_idx_map = {"1l" : 0, "1r": 1, "2l": 2, "2r": 3}
        self.row_map = {"1l" : 0, "1r": 0, "2l": 1, "2r": 1}
        self.col_map = {"1l" : 0, "1r": 1, "2l": 0, "2r": 1}
        self.chart_update_frequency = 2
        self.init()

    def init(self) -> None:
        self.init_ui()
        self.init_data()
        self.refresh_ui()

    def init_data(self) -> None:
        self.logger.debug("init_data called.")
        if os.path.exists(self.settings_file):
            self.logger.info(f"Found config data in {self.settings_file}")
            with open(self.settings_file, 'r', encoding='utf-8') as fid:
                self.config = yaml.safe_load(fid)
                self.provider_objs = dict.fromkeys(self.config["providers"].keys())
                for k, v in self.provider_objs.items():
                    self.provider_objs[k] = {}
        self.logger.info(f"Init config data {self.config}")
        self.update_chart_data_thread = threading.Thread(target=self.update_chart_data)
        self.update_chart_data_thread.start()

    def refresh_ui(self) -> None:
        self.logger.info("refresh_ui called.")
        self.login_btn.clicked.connect(self.ui_perform_login)
        self.index_name.currentIndexChanged.connect(self.ui_update_expiries)
        self.expiry.currentIndexChanged.connect(self.ui_get_atm_strikes)
        self.clear_nse_cache_btn.clicked.connect(self.ui_clear_nse_live_cache)
        self.new_order1l.clicked.connect(partial(self.ui_show_graph, "1l"))
        self.new_order1r.clicked.connect(partial(self.ui_show_graph, "1r"))
        self.new_order2l.clicked.connect(partial(self.ui_show_graph, "2l"))
        self.new_order2r.clicked.connect(partial(self.ui_show_graph, "2r"))
        self.place_order_shortcut.activated.connect(self.ui_place_order)
        self.buy_shortcut.activated.connect(partial(self.ui_select_action, "buy"))
        self.sell_shortcut.activated.connect(partial(self.ui_select_action, "sell")) 
        self.refresh_shortcut.activated.connect(partial(self.ui_refresh_broker_info))
        self.ui_update_expiries()
        self.ui_update_provider_states()

    def get_broker(self) -> BrokerService:
        broker_provider = self.broker.currentText()

        if broker_provider not in self.provider_objs:
            self.create_message(f"Provider {broker_provider} not found in provider objs (Available: {list(self.provider_objs.keys())}). Please report this bug.")
            return
        if "broker" not in self.provider_objs[broker_provider]:
            self.create_message(f"Provider does not support broker.")
            return
        broker = self.provider_objs[broker_provider]["broker"]
        if broker is None:
            self.create_message(f"Broker is not initialized.")
            return
        return broker

    def ui_refresh_broker_info(self):
        self.create_message("Refresh info shortcut pressed.")
        broker = self.get_broker()
        if broker is None:
            return
        orders = []
        try:
            orders = broker.broker.get_orders()
        except IOError:
            exc = traceback.format_exc()
            self.create_message("Broker did not work properly when fetching orders: {exc}")
        table_data = []
        for order in orders:
            table_data.append({"timestamp": order.timestamp.strftime("%m %b %H:%M "),
                               "order_type": order.order_type.value,
                               "scrip": order.scrip,
                               "quantity": order.quantity,
                               "limit": order.limit_price,                               
                               "state": order.state.value,
                               "trigger": order.trigger_price,
                               "exchange": order.exchange})
        table_data.reverse()
        self.orders.setModel(TableModel(pd.DataFrame(table_data)))
        self.orders.resizeColumnsToContents()
        positions = []
        try:
            positions = broker.broker.get_positions()
        except IOError:
            exc = traceback.format_exc()
            self.create_message("Broker did not work properly when fetching positions: {exc}")
        table_data = []
        for position in positions:
            table_data.append({"scip": position.scrip,
                               "quantity": position.quantity,
                               "avg_price": position.average_price})
        self.positions.setModel(TableModel(pd.DataFrame(table_data)))
        self.positions.resizeColumnsToContents()

    def ui_select_action(self, action: str):
        if action == "buy":
            self.buy_radio.setChecked(True)
            self.sell_radio.setChecked(False)
        elif action == "sell":
            self.buy_radio.setChecked(False)
            self.sell_radio.setChecked(True)

    def get_transaction_type(self):
        if self.buy_radio.isChecked:
            return TransactionType.BUY
        return TransactionType.SELL

    def ui_place_order(self):
        self.create_message(message="Preparing order.", title="Order")
        broker = self.get_broker()
        
        if broker is None:
            return
        scrip = self.scrip_list.currentText()
        exchange = "NFO"
        order_params = {"scrip": scrip,
                        "exchange": exchange,
                        "exchange_id": exchange,
                        "scrip_id": scrip,
                        "transaction_type": self.get_transaction_type()}
        opposite_tx = TransactionType.BUY
        if order_params["transaction_type"] == TransactionType.BUY:
            opposite_tx = TransactionType.SELL

        entry_order_params = copy.deepcopy(order_params)
        entry_order_params["order_type"] = OrderType.SL_LIMIT
        entry_order_params["trigger_price"] = float(self.entry_trigger.text())
        entry_order_params["limit_price"] = float(self.entry_order.text())
        entry_order_params["quantity"] = int(self.entry_lots.text())
        entry_order = Order(**entry_order_params)
        try:
            entry_order = broker.broker.place_order(entry_order)
            if entry_order is None:
                raise ValueError("Order not placed.")
            self.create_message(f"Entry order placed @ {self.entry_trigger.text()} for {self.entry_lots.text()} lots.", title="EntryOrder", preset=ToastPreset.SUCCESS_DARK)
        except:
            traceback.print_exc()
            self.create_message(f"Entry order FAILED @ {self.entry_trigger.text()} for {self.entry_lots.text()} lots.", title="EntryOrder", preset=ToastPreset.ERROR_DARK)
            return
        if entry_order is not None:
            if self.sl_order_enabled.isChecked():
                sl_order_params = copy.deepcopy(order_params)
                sl_order_params["order_type"] = OrderType.SL_LIMIT
                sl_order_params["trigger_price"] = float(self.sl_trigger.text())
                sl_order_params["limit_price"] = float(self.sl_order.text())
                sl_order_params["quantity"] = float(self.entry_lots.text())
                sl_order_params["parent_order_id"] = entry_order.order_id
                sl_order_params["transaction_type"] = opposite_tx
                sl_order = Order(**sl_order_params)
                try:
                    broker.broker.place_gtt_order(entry_order, sl_order)
                    self.create_message(f"SL order placed @ {self.sl_trigger.text()} for {self.entry_lots.text()} lots.", title="SlOrder", preset=ToastPreset.SUCCESS_DARK)
                except:
                    traceback.print_exc()
                    self.create_message(f"SL order FAILED @ {self.sl_trigger.text()} for {self.entry_lots.text()} lots.", title="SlOrder", preset=ToastPreset.ERROR_DARK)
            targets = ["target1", "target2", "target3"]
            for target in targets:
                
                if getattr(self, f"{target}_order_enabled").isChecked():
                    target_order_params = copy.deepcopy(order_params)
                    target_order_params["order_type"] = OrderType.LIMIT
                    target_order_params["limit_price"] = float(getattr(self, f"{target}_order").text())
                    target_order_params["quantity"] = float(getattr(self, f"{target}_lots").text())
                    target_order_params["parent_order_id"] = entry_order.order_id
                    target_order_params["transaction_type"] = opposite_tx
                    target_order = Order(**target_order_params)
                    try:
                        broker.broker.place_gtt_order(entry_order, target_order)
                        self.create_message(f"Target order placed @ {getattr(self, f'{target}_order').text()} for {getattr(self, f'{target}_lots').text()} lots.", title=f"{target}Order", preset=ToastPreset.SUCCESS_DARK)
                    except:
                        traceback.print_exc()
                        self.create_message(f"Target order FAILED @ {getattr(self, f'{target}_order').text()} for {getattr(self, f'{target}_lots').text()} lots.", title=f"{target}Order", preset=ToastPreset.ERROR_DARK)

    def ui_clear_nse_live_cache(self):
        try:
            self.nse_live_handler.clear_cache()
            self.create_message("NSE Cache cleared.")
        except:
            self.create_message("NSE Cache could not be cleared.")

    def create_message(self, message: str, title: str = None, duration: int = 5, preset: ToastPreset = None):
            toast = Toast(self.window)
            toast.setDuration(duration * 1000)
            if title is not None:
                toast.setTitle(title)
            toast.setText(message)
            if preset is not None:
                toast.applyPreset(preset)
            else:
                toast.applyPreset(ToastPreset.INFORMATION_DARK)
            toast.show()
            # dialog = QDialog()
            # ok = QPushButton("OK")
            # layout = QVBoxLayout()
            # message = QLabel(message)
            # layout.addWidget(message)
            # layout.addWidget(ok)
            # ok.clicked.connect(lambda x: dialog.close())
            # dialog.setLayout(layout)
            # dialog.exec()

    def create_input_dialog(self, message: str):
        name, done = QInputDialog.getText(self.window, message, message)
        if done:
            return name
        self.create_message("You cancelled the input dialog.")

    def try_login(self, provider: Service):
        not_ready = False
        for instruction in provider.login():
            if isinstance(instruction, bool):
                not_ready = not instruction
                break
            if isinstance(instruction, str):
                url = QUrl(instruction)
                QDesktopServices.openUrl(url)
            elif isinstance(instruction, dict):
                data = self.create_input_dialog(f'Enter {instruction["text"]}')
                provider.auth_inputs[instruction["field"]] = data
        provider.init()
        return not_ready

    def ui_perform_login(self):
        provider = self.login_providers.currentText().lower()
        if provider not in self.config["providers"]:
            self.create_message("Provider credentials not found.")
            return
        components = self.config["providers"][provider]
        refresh_cache = self.login_refresh_cache.isChecked()
        print(f"Refresh cache {refresh_cache}")
        not_ready = refresh_cache
        if "historic_data_provider_class" in components:
            self.provider_objs[provider]["historic"] = DataProviderService(data_path=self.config["data_path"],
                                                                           DataProviderClass=components["historic_data_provider_class"],
                                                                           data_provider_login=False,
                                                                           data_provider_init=False,
                                                                           instruments=[],
                                                                           StorageClass=self.config["storage_class"],
                                                                           data_provider_auth_credentials=components["auth_credentials"],
                                                                           data_provider_auth_cache_filepath=self.config["auth_cache_filepath"],
                                                                           data_provider_reset_auth_cache=not_ready)
            not_ready = self.try_login(self.provider_objs[provider]["historic"].data_provider)

        if "streaming_provider_class" in components:
            self.provider_objs[provider]["live"] = DataProviderService(data_path=self.config["data_path"],
                                                                       DataProviderClass=components["streaming_provider_class"],
                                                                       data_provider_login=False,
                                                                       data_provider_init=False,
                                                                       instruments=[],
                                                                       StorageClass=self.config["storage_class"],
                                                                       data_provider_auth_credentials=components["auth_credentials"],
                                                                       data_provider_auth_cache_filepath=self.config["auth_cache_filepath"],
                                                                       data_provider_reset_auth_cache=not_ready)
            not_ready = self.try_login(self.provider_objs[provider]["live"].data_provider)
        
        if "broker_class" in components:
            self.provider_objs[provider]["broker"] = BrokerService(data_path=self.config["data_path"],
                                                                   BrokerClass=components["broker_class"],
                                                                   broker_audit_records_path=components["broker_audit_records_path"],
                                                                   broker_login=False,
                                                                   broker_init=False,
                                                                   instruments=[],
                                                                   StorageClass=self.config["storage_class"],
                                                                   broker_auth_credentials=components["auth_credentials"],
                                                                   broker_auth_cache_filepath=self.config["auth_cache_filepath"],
                                                                   broker_reset_auth_cache=not_ready)
            not_ready = self.try_login(self.provider_objs[provider]["broker"].broker)
        state = "Success"
        if not_ready:
            state = "Failure"
        self.create_message(f"Login state: {state}")
        self.provider_objs[provider]["state"] = not not_ready
        self.ui_update_provider_states()
        self.start_streams(provider)

    def start_streams(self, provider: str):
        if self.start_streamers.isChecked():
            provider_obj = self.provider_objs[provider]
            if "live" in provider_obj and provider_obj["live"] is not None:
                self.create_message(f"Starting live streamer for {provider}")
                provider_obj["live"].data_provider.start([])
            if "broker" in provider_obj and provider_obj["broker"] is not None:
                self.create_message(f"Starting broker order streamer for {provider}")
                provider_obj["broker"].broker.start()

    def ui_update_provider_states(self):
        self.historic_data_provider.clear()
        self.live_data_provider.clear()
        self.broker.clear()
        summary = []
        for provider, obj in self.provider_objs.items():
            data = {"Name": provider, "H": "N", "L": "N", "B": "N", "State": "N/A"}
            if "historic" in obj:
                data["H"] = "Y"
                self.historic_data_provider.addItem(provider)
            if "live" in obj:
                data["L"] = "Y"
                self.live_data_provider.addItem(provider)
            if "broker" in obj:
                data["B"] = "Y"
                self.broker.addItem(provider)
            if "state" in obj:
                if obj["state"]:
                    data["State"] = "Logged in"
                else:
                    data["State"] = "Login Failed"
            summary.append(data)
        self.login_status_list.setModel(TableModel(pd.DataFrame(summary)))
        self.login_status_list.resizeColumnsToContents()
        

    def get_some_obj(provider_data: dict):
        for item in ["historic", "live", "broker"]:
            if item in provider_data and provider_data[item] is not None:
                return provider_data[item]

    def ui_update_expiries(self):
        index = self.index_name.currentText()
        expiries = self.nse_live_handler.get_expiries(index)
        self.expiry.clear()
        self.expiry.addItems(expiries)
        # self.ui_get_atm_strikes()
    
    def ui_get_atm_strikes(self):
        self.scrip_list.clear()
        index = self.index_name.currentText()
        expiry = self.expiry.currentText()
        if expiry == "":
            return
        print("EXpiry", expiry)
        opts = self.nse_live_handler.get_strikes(index, expiry=expiry)
        self.scrip_list.clear()
        self.scrip_list.addItems(opts)

    def get_historic_data_provider(self) -> DataProviderService:
        historic_data_provider = self.historic_data_provider.currentText().lower()
        if historic_data_provider not in self.provider_objs:
            self.create_message(f"Provider {historic_data_provider} not found in provider objs (Available: {list(self.provider_objs.keys())}). Please report this bug.")
            return
        if "historic" not in self.provider_objs[historic_data_provider]:
            self.create_message(f"Provider does not support historic data.")
            return
        historic_data_provider = self.provider_objs[historic_data_provider]["historic"]
        if historic_data_provider is None:
            self.create_message(f"Historic data provider is not initialized.")
            return
        return historic_data_provider

    def get_ohlc_data(self, scrip: str):
        historic_data_provider = self.get_historic_data_provider()
        if historic_data_provider is None:
            return
        if self.bot is None:
            self.bot  = Bot(None, EMAStrategy(), historic_data_provider.data_provider, online_mode=self.online_mode.isChecked(), live_data_context_size= 15)
        else:
            self.bot.online_mode = self.online_mode.isChecked()
        recent_data = self.bot.get_recent_data(instruments=[{"exchange": "NFO", "scrip" : scrip}])
        return recent_data[list(recent_data.keys())[0]]["data"]

    def get_live_data_provider(self):
        live_data_provider = self.live_data_provider.currentText().lower()
        if live_data_provider not in self.provider_objs:
            self.create_message(f"Provider {live_data_provider} not found in provider objs (Available: {list(self.provider_objs.keys())}). Please report this bug.")
            return
        if "live" not in self.provider_objs[live_data_provider]:
            self.create_message(f"Provider does not support live data.")
            return
        live_data_provider = self.provider_objs[live_data_provider]["live"]
        if live_data_provider is None:
            self.create_message(f"Live data provider is not initialized.")
            return
        return live_data_provider

    def update_streamer(self, location):
        if self.start_streamers.isChecked():
            live_data_provider = self.get_live_data_provider()
            if live_data_provider is None:
                return
            scrip = self.scrip_list.currentText()
            if self.ui_instruments[location] == scrip:
                return
            if self.ui_instruments[location] is not None:
                live_data_provider.data_provider.unsubscribe([{"scrip": self.ui_instruments[location], "exchange": "NFO"}])
            self.ui_instruments[location] = scrip
            live_data_provider.data_provider.subscribe([{"exchange": "NFO", "scrip" : scrip}])

    def update_chart_data(self):
        while True:
            if self.start_streamers.isChecked():
                for location, scrip in self.ui_instruments.items():
                    if scrip is None:
                        continue
                    data = self.get_ohlc_data(scrip)
                    idx = self.location_idx_map[location]
                    try:
                        self.figures[idx].update(data.iloc[-1])
                    except:
                        traceback.print_exc()
            time.sleep(self.chart_update_frequency)

    def ui_show_graph(self, location):
        scrip = self.scrip_list.currentText()
        self.update_streamer(location)
        idx = self.location_idx_map[location]
        self.graphics_area_layout.removeWidget(self.canvases[idx])
        self.canvases[idx].deleteLater()
        # self.canvas = FigureCanvas(fig)
        # self.nav_bar = NavigationToolbar(self.canvas)
        # self.graphics_area_layout.addWidget(self.canvas, stretch=3)
        # self.graphics_area_layout.addWidget(self.nav_bar, stretch=3)
        canvas = QWidget()
        self.figures[idx] = QtChart(canvas)
        self.figures[idx].legend(True)
        self.figures[idx].topbar.textbox('symbol', scrip)
        self.figures[idx].events.click += partial(self.ui_on_graph_click, location, scrip)
        self.canvases[idx] = self.figures[idx].get_webview()
        data = self.get_ohlc_data(scrip)
        self.figures[idx].set(data)
        self.graphics_area_layout.addWidget(self.canvases[idx], self.row_map[location], self.col_map[location])
        self.graphics_area_layout.setContentsMargins(0, 0, 0, 0)

    def ui_on_graph_click(self, location, scrip, chart, *args):
        print(location, scrip, chart, args)

        barindex = args[0]
        timestamp = args[1]
        open = args[2]
        high = args[3]
        low = args[4]
        close = args[5]
        col = "red"
        if scrip.endswith("CE"):
            col = "green"
        action = "BUY" if self.buy_radio.isChecked() else "SELL"
        tolerance = float(self.tol_edit.text())
        slippage = float(self.slippage_edit.text())
        rr = float(self.rr_edit.text())
        entry_trigger, entry_limit, sl_trigger, sl_limit, target1, target2, target3 = 0, 0, 0, 0, 0, 0, 0
        action_col = "green"
        if action == "BUY":
            entry_trigger = high + tolerance
            entry_limit = high + tolerance + slippage
            sl_trigger = max(low - tolerance, 0)
            sl_limit = max(low - tolerance - slippage, 0)
            diff = entry_trigger - sl_trigger
            target1 = round(high + (diff) * rr, 1)
            target2 = round(high + (diff) * (rr + 1), 1)
            target3 = round(high + (diff) * (rr + 2), 1)
        else:
            sl_trigger = high + tolerance
            sl_limit = high + tolerance + slippage
            entry_trigger = max(low - tolerance, 0)
            entry_limit = max(low - tolerance - slippage, 0)
            diff = sl_trigger - entry_trigger
            target1 = round(low - (diff) * rr, 1)
            target2 = round(low - ((diff) * (rr + 1)), 1)
            target3 = round(low - ((diff) * (rr + 2)), 1)
            action_col = "red"
        lot_size = 25
        if "BANKNIFTY" in scrip:
            lot_size = 15
        elif "NIFTY" in scrip:
            lot_size = 25
        max_loss = lot_size * abs(sl_limit - entry_limit) * int(self.entry_lots.text())
        max_profit = lot_size * abs(target1 - entry_trigger) * int(self.entry_lots.text())
        # self.create_order.setText(f'''<b style="display:inline;color:yellow; font_size: 16px">{location.upper()} </b> | <b style="display:inline; font-size: 16px; color:{col}">{scrip}</b> | <b style="color:{action_col}; font-size: 14px">{action}</b><br><b>O:</b> {open}, <b>H:</b> {high}, <b>L:</b> {low}, <b>C:</b> {close}<br><b style="color: blue">ENT</b> SL-LMT TRG: {entry_trigger} LMT: {entry_limit}<br><b style="color: red">SL</b> SL-LMT TRG: {sl_trigger} LMT: {sl_limit} | <b style="color: green">TGT</b> LMT: {target}<br><b style="color:green; font-size: 14px">Max Profit: {max_profit:.1f}</b><br><b style="color:red; font-size: 14px">Max Loss: {max_loss:.1f}</b>''')
        self.entry_order.setText(f"{entry_limit:0.2f}")
        self.sl_order.setText(f"{sl_limit:0.2f}")
        self.entry_trigger.setText(f"{entry_trigger:0.2f}")
        self.sl_trigger.setText(f"{sl_trigger:0.2f}")
        self.target1_order.setText(f"{target1:0.2f}")
        self.target2_order.setText(f"{target2:0.2f}")
        self.target3_order.setText(f"{target3:0.2f}")

        self.anticipated_profit.setText(f"{max_profit:.2f}")
        self.anticipated_loss.setText(f"{max_loss:.2f}")

    def init_ui(self) -> None:
        self.app = QApplication([])

        self.window = QWidget()
        self.window.setWindowTitle("Quaint Scalper")
        
        self.side_widget = QListWidget()

        self.side_widget_layout = QVBoxLayout()
        self.login_status_tab = QWidget()
        self.login_status_layout = QVBoxLayout()
        self.login_status_list = QTableView()
        self.logout_button = QPushButton("Logout")
        self.control_tabs = QTabWidget()
        self.login_btn = QPushButton("Login")
        self.clear_nse_cache_btn = QPushButton("Clear NSE Cache")
        self.login_providers = QComboBox()
        self.login_providers.addItems(INTEGRATIONS)
        self.login_refresh_cache = QCheckBox()
        self.start_streamers = QCheckBox()
        self.historic_data_provider = QComboBox()
        self.historic_data_provider.addItems(INTEGRATIONS)
        self.live_data_provider = QComboBox()
        self.live_data_provider.addItems(INTEGRATIONS)
        self.broker = QComboBox()
        self.broker.addItems(INTEGRATIONS)
        self.online_mode = QCheckBox()
        login_options_widget = QWidget()
        login_options_layout = QGridLayout()
        
        login_options_layout.addWidget(QLabel("Refresh login cache"), 0, 0)
        login_options_layout.addWidget(self.login_refresh_cache, 0, 1)
        login_options_layout.addWidget(QLabel("Start Streamers"), 1, 0)        
        login_options_layout.addWidget(self.start_streamers, 1, 1)
        login_options_layout.addWidget(QLabel("Online Mode"), 2, 0)        
        login_options_layout.addWidget(self.online_mode, 2, 1)
        login_options_layout.addWidget(self.login_providers, 3, 0)
        login_options_layout.addWidget(self.login_btn, 3, 1)
        login_options_widget.setLayout(login_options_layout)
        login_options_layout.addWidget(QLabel("Clear NSE Cache"), 4, 0)
        login_options_layout.addWidget(self.clear_nse_cache_btn, 4, 1)
        login_options_layout.addWidget(QLabel("Historic Data Provider"), 5, 0)
        login_options_layout.addWidget(self.historic_data_provider, 5, 1)
        login_options_layout.addWidget(QLabel("Live Data Provider"), 6, 0)
        login_options_layout.addWidget(self.live_data_provider, 6, 1)
        login_options_layout.addWidget(QLabel("Broker"), 7, 0)
        login_options_layout.addWidget(self.broker, 7, 1)


        self.login_status_layout.addWidget(login_options_widget)
        
        
        self.login_status_layout.addWidget(QLabel("Login status of providers"))
        self.login_status_layout.addWidget(self.login_status_list)
        self.login_status_layout.addWidget(self.logout_button)
        self.login_status_tab.setLayout(self.login_status_layout)

        self.order_tab = QWidget()
        self.order_tab_layout = QVBoxLayout()

        self.create_order = QWidget()
        create_order_layout = QGridLayout()
        self.create_order.setLayout(create_order_layout)
        self.entry_order = QLineEdit()
        self.sl_order = QLineEdit()
        self.entry_trigger = QLineEdit()
        self.sl_trigger = QLineEdit()
        self.target1_order = QLineEdit()
        self.target2_order = QLineEdit()
        self.target3_order = QLineEdit()

        self.entry_order_enabled = QCheckBox()
        self.entry_lots = QLineEdit()
        self.entry_lots.setText("1")
        self.entry_order_enabled.setChecked(True)
        self.sl_order_enabled = QCheckBox()
        self.sl_order_enabled.setChecked(True)
        self.target1_order_enabled = QCheckBox()
        self.target1_order_enabled.setChecked(True)
        self.target1_lots = QLineEdit()
        self.target1_lots.setText("1")
        self.target2_order_enabled = QCheckBox()
        self.target2_lots = QLineEdit()
        self.target3_order_enabled = QCheckBox()
        self.target3_lots = QLineEdit()

        create_order_layout.addWidget(QLabel("Entry"), 0, 0)
        create_order_layout.addWidget(self.entry_trigger, 0, 1)
        create_order_layout.addWidget(QLabel("Lots"), 0, 2)
        create_order_layout.addWidget(self.entry_lots, 0, 3)
        create_order_layout.addWidget(self.entry_order_enabled, 0, 4)

        create_order_layout.addWidget(QLabel("SL"), 1, 0)
        create_order_layout.addWidget(self.sl_trigger, 1, 1)
        create_order_layout.addWidget(self.sl_order_enabled, 1, 4)

        create_order_layout.addWidget(QLabel("Target1"), 2, 0)
        create_order_layout.addWidget(self.target1_order, 2, 1)
        create_order_layout.addWidget(QLabel("Lots"), 2, 2)
        create_order_layout.addWidget(self.target1_lots, 2, 3)
        create_order_layout.addWidget(self.target1_order_enabled, 2, 4)

        create_order_layout.addWidget(QLabel("Target2"), 3, 0)
        create_order_layout.addWidget(self.target2_order, 3, 1)
        create_order_layout.addWidget(QLabel("Lots"), 3, 2)
        create_order_layout.addWidget(self.target2_lots, 3, 3)
        create_order_layout.addWidget(self.target2_order_enabled, 3, 4)

        create_order_layout.addWidget(QLabel("Target3"), 4, 0)
        create_order_layout.addWidget(self.target3_order, 4, 1)
        create_order_layout.addWidget(QLabel("Lots"), 4, 2)
        create_order_layout.addWidget(self.target3_lots, 4, 3)
        create_order_layout.addWidget(self.target3_order_enabled, 4, 4)
        self.anticipated_profit = QTextEdit()
        self.anticipated_profit.setReadOnly(True)
        self.anticipated_profit.setMaximumHeight(20)
        self.anticipated_profit.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.anticipated_profit.setTextColor(Qt.GlobalColor.green)
        self.anticipated_loss = QTextEdit()
        self.anticipated_loss.setMaximumHeight(20)
        self.anticipated_loss.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.anticipated_loss.setReadOnly(True)
        self.anticipated_loss.setTextColor(Qt.GlobalColor.red)
        create_order_layout.addWidget(QLabel("Max Profit"), 5, 0)
        create_order_layout.addWidget(self.anticipated_profit, 5, 1)
        create_order_layout.addWidget(QLabel("Max Loss"), 5, 2)
        create_order_layout.addWidget(self.anticipated_loss, 5, 3)
        
        self.delete_order = QPushButton("Delete Order")
        self.orders = QTableView()
        self.positions = QTableView()
        self.squareoff_position = QPushButton("Squareoff Position")
        radio_widget = QWidget()
        radio_widget_layout = QHBoxLayout()
        radio_widget.setLayout(radio_widget_layout)
        self.buy_radio = QRadioButton("BUY")
        self.buy_radio.setChecked(True)
        self.buy_radio.action = "BUY"
        self.buy_radio.setStyleSheet('QRadioButton{font: 20pt Helvetica MS;color: green} QRadioButton::indicator { width: 20px; height: 20px;};')
        self.sell_radio = QRadioButton("SELL")
        self.sell_radio.action = "SELL"
        self.sell_radio.setStyleSheet('QRadioButton{font: 20pt Helvetica MS;color: red} QRadioButton::indicator { width: 20px; height: 20px;};')
        tol_widget = QWidget()
        tol_widget_layout = QHBoxLayout()
        tol_widget.setLayout(tol_widget_layout)
        self.tol_edit = QLineEdit()
        self.tol_edit.setText("1")
        self.slippage_edit = QLineEdit()
        self.slippage_edit.setText("1")
        self.rr_edit = QLineEdit()
        self.rr_edit.setText("2")
        tol_widget_layout.addWidget(QLabel("Filter"))
        tol_widget_layout.addWidget(self.tol_edit)
        tol_widget_layout.addWidget(QLabel("Slip"))
        tol_widget_layout.addWidget(self.slippage_edit)
        tol_widget_layout.addWidget(QLabel("R:R"))
        tol_widget_layout.addWidget(self.rr_edit)
        radio_widget_layout.addWidget(self.buy_radio)
        radio_widget_layout.addWidget(self.sell_radio)

        self.place_order_shortcut = QShortcut("Ctrl+Shift+A", self.window)
        self.buy_shortcut = QShortcut("Ctrl+Shift+B", self.window)
        self.sell_shortcut = QShortcut("Ctrl+Shift+S", self.window)
        self.refresh_shortcut = QShortcut("Ctrl+Shift+R", self.window)
        self.update_lots_shortcut = QShortcut("Ctrl+Shift+X", self.window)

        self.graphs_tab = QWidget()
        graphs_tab_layout = QGridLayout()
        self.graphs_tab.setLayout(graphs_tab_layout)
        
        self.index_name = QComboBox()
        self.index_name.addItems(["NIFTY", "BANKNIFTY"])
        self.expiry = QComboBox()

        self.scrip_list = QComboBox()
        self.new_order1l = QPushButton("1L")
        self.new_order1l.setFixedHeight(40)
        self.new_order1r = QPushButton("1R")
        self.new_order1r.setFixedHeight(40)
        self.new_order2l = QPushButton("2L")
        self.new_order2l.setFixedHeight(40)
        self.new_order2r = QPushButton("2R")
        self.new_order2r.setFixedHeight(40)
        self.refresh_scrips = QPushButton("Refresh Scrips")
        self.order_tab_layout.addWidget(self.create_order)
        self.order_tab_layout.addWidget(radio_widget)
        self.order_tab_layout.addWidget(tol_widget)
        self.order_tab_layout.addWidget(self.orders)
        self.order_tab_layout.addWidget(self.delete_order)
        self.order_tab_layout.addWidget(self.positions)
        self.order_tab_layout.addWidget(self.squareoff_position)
        self.order_tab.setLayout(self.order_tab_layout)

        graphs_tab_layout.addWidget(self.index_name, 0, 0)
        graphs_tab_layout.addWidget(self.expiry, 0, 1)
        graphs_tab_layout.addWidget(self.scrip_list, 1, 0, 1, 2)
        

        graphs_tab_layout.addWidget(self.new_order1l, 2, 0)
        graphs_tab_layout.addWidget(self.new_order1r, 2, 1)
        graphs_tab_layout.addWidget(self.new_order2l, 3, 0)
        graphs_tab_layout.addWidget(self.new_order2r, 3, 1)
        spacer = QSpacerItem(10, 20, vPolicy=QSizePolicy.Policy.Expanding)
        graphs_tab_layout.addItem(spacer, 4, 0)
        self.control_tabs.addTab(self.login_status_tab, "Setup")
        self.control_tabs.addTab(self.order_tab, "Orders")
        self.control_tabs.addTab(self.graphs_tab, "Graphs")

        self.side_widget_layout.addWidget(self.control_tabs)
        self.side_widget.setLayout(self.side_widget_layout)

        self.working_area = QWidget()
        self.working_area_layout = QHBoxLayout()
        self.working_area_layout.addWidget(self.side_widget, 1)
        self.graphics_area = QWidget()
        self.graphics_area_layout = QGridLayout()
        self.graphics_area.setLayout(self.graphics_area_layout)
        self.figure = Figure()
        self.canvas = FigureCanvas(self.figure)
        self.figures = []
        self.canvases = []
        for ii in range(0, 4):
            self.figures.append(Figure())
            self.canvases.append(FigureCanvas(self.figures[-1]))
        self.working_area_layout.addWidget(self.graphics_area, 3)
        self.working_area.setLayout(self.working_area_layout)

        self.graphics_area_layout.addWidget(self.canvases[0], 0, 0)
        self.graphics_area_layout.addWidget(self.canvases[1], 0, 1)
        self.graphics_area_layout.addWidget(self.canvases[2], 1, 0)
        self.graphics_area_layout.addWidget(self.canvases[3], 1, 1)        

        self.main_layout = QVBoxLayout()
        self.main_layout.addWidget(self.working_area)
        self.window.setLayout(self.main_layout)

    def run(self) -> None:
        self.window.show()
        sys.exit(self.app.exec())


app = ScalperApp()
app.run()